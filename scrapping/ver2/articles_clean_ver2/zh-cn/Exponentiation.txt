目录
重要的恒等式
运算律
整数指数幂
正实数的实数幂
负实数的实数幂
正实数的复数幂
复数的复数幂
在函数中
在抽象代数中
计算自然数（正整数）
的算法
注释
另见
外部连结
导航菜单
运算法则
其他等式
正整数指数幂
指数是1或者0
零的零次方
负数指数
特殊数的幂
指数非常大时的幂
N次方根
有理数幂
e的幂
实数指数幂
e的虚数次幂
三角函数
e的复数指数幂
正实数的复数幂
复数的虚数幂
复数的复数幂
一般情况
个人工具
命名空间
查看
搜索
导航
帮助
工具
打印/导出
在其他项目中
其他语言
10的幂
2的幂
1的幂
0的幂
负1的幂
幂运算（英语：exponentiation），又称指数运算，是数学运算，表达式为 
读作“
的 
次方”或「
的 
次幂」。
其中，
称为底数，而 
称为指数，通常指数写成上标，放在底数的右边。
当不能用上标时，例如在编程语言或电子邮件中，
通常写成 bn 或 b**n；也可视为超运算，记为 bn；亦可以用高德纳箭号表示法，写成 bn。
若n为正整数，可以把 
看作乘方的结果，等同于 
自乘 
次。
当指数为 1 时，通常不写出来，因为运算出的值和底数的数值一样；指数为 2 时，可以读作“
的平方”；指数为 3 时，可以读作“
的立方”。
起始值 1（乘法的单位元）乘上底数（
）自乘指数（
）这么多次。
这样定义了后，很易想到如何一般化指数 0 和负数的情况：除 0 外所有数的零次方都是 1 ；指数是负数时就等于重复除以底数（或底数的倒数自乘指数这么多次），即：
以分数为指数的幂定义为 
=
即 
次方再开 
次方根
0的0次方目前没有数学家给予正式的定义。
在部分数学领域中，如组合数学，常用的惯例是定义为 1 ，也有人主张定义为 1 。
因为在十进制，十的次方很易计算，只需在后面加零即可，所以科学记数法借此简化记录的数字；二的幂在计算机科学相当重要。
当n是复数及b是正实数时,
exp 是指数函数而 ln 是自然对数。
加法和乘法存在交换律，比如：
+
=
=
+
×
=
=
×
但是幂的运算不存在交换律，
=
但是
=
同样，加法和乘法存在结合律，比如：
+
+
=
=
+
+
×
×
=
24
=
×
×
。
不过，幂运算没有结合律：
=
=
4096
=
81
=
417
851
639
229
258
349
412
352
所以
≠
但是幂运算仍然有其运算律，称为指数律：
整数指数幂的运算只需要初等代数的知识。
表达式
=
⋅
被称作
的平方，因为边长为
的正方形面积是
表达式
=
⋅
⋅
被称作
的立方，因为边长为
的正方体体积是
所以
读作「3的平方」，
读作「2的立方」。
指数表示的是底数反复相乘多少次。
比如
=
×
×
×
×
=
243
指数是5，底数是3，表示3反复相乘5次。
或者，整数指数幂可以递归地定义成：
注意
表示仅仅1个3的乘积，就等于3。
注意
=
×
=
×
=
×
=
×
继续，得到
=
×
=
所以
=
另一个得到此结论的方法是：通过运算法则
=
−
=
时，
=
=
−
=
其实还并未被数学家完整的定义，但部分看法是
=
在程式语言中（python） 
∗
∗
=
在这里给出这一种极限的看法
lim
+
=
于是，可以求出 x 取值从 1 到 0.0000001 计算得到的值，如图
我们定义任何不为 0 的数 a 的 -1 次方等于它的倒数。
对于非零
定义
=
时分母为 0 没有意义。
证法一：
根据定义
⋅
=
+
=
−
−
=
所以
−
=
证法二：
通过运算法则
=
−
=
时，可得
−
=
−
=
=
负数指数
−
还可以表示成1连续除以
。
比如：
在十进制的计数系统中，10的幂写成1后面跟着很多个0。
例如：
10
=
1000
10
−
=
0.001
因此10的幂用来表示非常大或者非常小的数字。
如：299,792,458（真空中光速，单位是米每秒），可以写成 
2.99792458
×
10
近似值 
2.998
×
10
或 
×
10
国际单位制词头也使用10的幂来描述特别大或者特别小的数字，比如：词头“千”就是 
10
词头“毫”就是 
10
−
1的任何次幂都为1
0的正数幂都等于0。
0的负数幂没有定义。
任何非0之数的0次方都是1；而0的0次方是悬而未决的，某些领域下常用的惯例是约定为1。
但某些教科书表示0的0次方为无意义。
也有人主张定义为1。
-1的奇数幂等于-1
-1的偶数幂等于1
一个大于1的数的幂趋于无穷大，一个小于-1的数的幂趋于负无穷大
一个绝对值小于1的数的幂趋于0
1的幂永远都是1
如果数a趋于1而它的幂趋于无穷，那么极限并不一定是上面几个。
一个很重要的例子是：
参见e的幂
其他指数的极限参见幂的极限
一个正实数的实数幂可以通过两种方法实现。
一个数
次方根是
=
如果
是一个正实数，
是正整数，那么方程
=
只有一个正实数根。
这个根被称为
次方根，记作：
其中
叫做根号。
或者，
次方根也可以写成
例如
=
=
当指数是
时根号上的2可以省略，如：
=
=
=
有理数指数幂定义为
这个重要的数学常数e，有时叫做欧拉数，近似2.718，是自然对数的底。
它提供了定义非整数指数幂的一个方法。
它是从以下极限定义的：
指数函数的定义是：
可以很简单地证明e的正整数k次方
是：
因为所有实数可以近似地表示为有理数，任意实数指数x可以定义成：
例如：
于是
实数指数幂通常使用对数来定义，而不是近似有理数。
自然对数
ln
⁡
是指数函数
的反函数。
它的定义是：对于任意
>
满足
根据对数和指数运算的规则：
这就是实数指数幂的定义：
实数指数幂
的这个定义和上面使用有理数指数和连续性的定义相吻合。
对于复数，这种定义更加常用。
如果
是负数且
是偶数，那么
=
是正数。
如果
是负数且
是奇数，那么
=
是负数。
使用对数和有理数指数都不能将
（其中
是负实数，
实数）定义成实数。
在一些特殊情况下，给出一个定义是可行的：负指数的整数指数幂是实数，有理数指数幂对于
（
是奇数）可以使用
次方根来计算，但是因为没有实数
=
−
对于
（
是偶数）时必须使用虚数单位
使用对数的方法不能定义
≤
时的
为实数。
实际上，
对于任何实数
都是正的，所以
ln
⁡
对于负数没有意义。
使用有理数指数幂来逼近的方法也不能用于负数
因为它依赖于连续性。
函数
=
对于任何正的有理数
是连续的，但是对于负数
函数
在有些有理数
上甚至不是连续的。
例如：当
=
−
它的奇数次根等于-1。
所以如果
是正奇数整数，
−
=
−
是奇数，
−
=
是偶数。
虽然有理数
−
=
的集合是稠密集，但是有理数
−
=
−
的集合也是。
所以函数
−
在有理数域不是连续的。
因此，如果要求负实数的任意实数幂，必须将底数和指数看成复数，按复数的正实数幂或复数的复数幂方法计算。
复数运算的几何意义和e的幂可以帮助我们理解
（
是实数），即纯虚数指数函数。
想象一个直角三角形
+
（括号内是复数平面内三角形的三个顶点），对于足够大的
这个三角形可以看作一个扇形，这个扇形的中心角就等于
弧度。
对于所有
三角形
+
+
+
互为相似三角形。
所以当
足够大时
+
的极限是复数平面上的单位圆上
弧度的点。
这个点的极坐标是
=
直角坐标是
cos
⁡
sin
⁡
。
所以
=
cos
⁡
+
sin
⁡
而这个函数可以称为纯虚数指数函数。
这就是欧拉公式，它通过复数的意义将代数学和三角学联系起来了。
等式
=
的解是一个整数乘以
：
更一般地，如果
=
那么
=
的每一个解都可以通过将
的整数倍加上
得到：
这个复指数函数是一个有周期
的周期函数。
更简单的：
=
−
;
+
=
cos
⁡
+
sin
⁡
根据欧拉公式，三角函数余弦和正弦是：
历史上，在复数发明之前，余弦和正弦是用几何的方法定义的。
上面的公式将复杂的三角函数的求和公式转换成了简单的指数方程
使用了复数指数幂之后，很多三角学问题都能够使用代数方法解决。
+
可以分解成
⋅
。
其中
+
的模，
决定了
+
的方向
如果
是一个正实数，
是任何复数，
定义成
⋅
ln
⁡
其中
=
ln
⁡
是方程
=
的唯一解。
所以处理实数的方法同样可以用来处理复数。
例如：
让我们从一个简单的例子开始：计算
+
+
=
[
+
]
=
=
−
=
−
cos
⁡
ln
⁡
+
−
sin
⁡
ln
⁡
其中
的得法参见上文正实数的复数幂
类似地，在计算复数的复数幂时，我们可以将指数的实部与虚部分开以进行幂计算。
例如计算
+
+
：
+
+
=
+
+
=
−
cos
⁡
ln
⁡
+
sin
⁡
ln
⁡
=
−
−
sin
⁡
ln
⁡
+
−
cos
⁡
ln
⁡
复数的复数幂必须首先化为底数为
的形式：
=
ln
⁡
又，由复数的极坐标表示法：
=
=
ln
⁡
=
ln
⁡
+
然后，使用欧拉公式处理即可。
由于复数的极坐标表示法中，辐角
的取值是具有周期性的，因此复数的复数幂在大多数情况下是多值函数。
不过实际应用中，为了简便起见，辐角都只取主值，从而使幂值唯一。
当函数名后有上标的数（即函数的指数），一般指要重复它的运算。
例如
。
特别地，
−
的反函数。
但三角函数的情况有所不同，一个正指数应用于函数的名字时，指答案要进行乘方运算，而指数为-1时则表示其反函数。
例如：
sin
⁡
−
表示
csc
⁡
。
因此在三角函数时，使用
sin
−
⁡
来表示
sin
⁡
的反函数
arcsin
⁡
最快的方式计算
是正整数的时候。
它利用了测试一个数是奇数在计算机上是非常容易的，和通过简单的移所有位向右来除以2的事实。
伪代码：
在C/C++语言中，你可以写如下算法：
此算法的时间复杂度为
log
⁡
比普通算法快（a自乘100次，时间复杂度为
），在
较大的时候更为显着。
例如计算
100
普通算法需要算100次，上述算法则只需要算7次。
若要计算
<
可先以上述算法计算
|
|
再作倒数。
